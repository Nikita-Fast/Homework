package com.company;import com.company.algorithms.LeftToRightParallelScan;import com.company.auxiliaries.Cell;import com.company.auxiliaries.Result;import com.company.operations.Operation;import com.company.threads.LeftToRightParallelScanThread;public class TurtleDstCalculation  {    private Cell<MyVector>[][] sendReceiveTable;    private Thread[] threads;    public void scan(int threadsNumber, MyVector[] array, Result<MyVector> saveResultHere) {        initSendReceiveTable(threadsNumber);        initThreads(threadsNumber, array, saveResultHere);        startThreads(threadsNumber);    }    private void startThreads(int threadsNumber) {        for (int i = 0; i < threadsNumber; i++) {            threads[i].start();        }        for (Thread thread : threads) {            try {                thread.join();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void initThreads(int threadsNumber, MyVector[] array, Result<MyVector> result) {        int step = array.length / threadsNumber;        int min = 0;        int max = step - 1;        threads = new LeftToRightParallelScanThread[threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            threads[i] = new LeftToRightParallelScanThread<>(min, max, array, i, sendReceiveTable,                    threadsNumber, new VectorAddition(), result);            min += step;            max += step;            if (i == threadsNumber - 2) {                max = array.length - 1;            }        }    }    private void initSendReceiveTable(int threadsNumber) {        sendReceiveTable = new Cell[threadsNumber][threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            for (int j = 0; j < threadsNumber; j++) {                sendReceiveTable[i][j] = new Cell<>();            }        }    }}