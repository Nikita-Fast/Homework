package com.company.algorithms;import com.company.threads.BracketsMatchingThread;import com.company.auxiliaries.Cell;import com.company.auxiliaries.Result;public class ParallelBracketsMatching {    private Cell<Integer>[][] sendReceiveTable;    private Thread[] myThreads;    public boolean res = false;    public void scan(int threadsNumber, Integer[] array, Result<Integer> resultOfFindingMin) {        initSendReceiveTable(threadsNumber);        initThreads(threadsNumber, array, resultOfFindingMin);        startThreads(threadsNumber);        if (resultOfFindingMin.getResult() >= 0 && array[array.length - 1] == 0) {            res = true;        }    }    private void startThreads(int threadsNumber) {        for (int i = 0; i < threadsNumber; i++) {            myThreads[i].start();        }        for (Thread thread : myThreads) {            try {                thread.join();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void initThreads(int threadsNumber, Integer[] array, Result<Integer> resultOfFindingMin) {        int step = array.length / threadsNumber;        int min = 0;        int max = step - 1;        myThreads = new BracketsMatchingThread[threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            myThreads[i] = new BracketsMatchingThread(min, max, array, i, sendReceiveTable, threadsNumber, resultOfFindingMin);            min += step;            max += step;            if (i == threadsNumber - 2) {                max = array.length - 1;            }        }    }    private void initSendReceiveTable(int threadsNumber) {        sendReceiveTable = new Cell[threadsNumber][threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            for (int j = 0; j < threadsNumber; j++) {                sendReceiveTable[i][j] = new Cell<>();            }        }    }}