package com.company.algorithms;import com.company.auxiliaries.Cell;import com.company.operations.Operation;import com.company.threads.ParallelPrefixScanThread;public class ParallelPrefixScan<T> {    private Cell<T>[][] sendReceiveTable;    //private ParallelPrefixScanThread<T>[] myThreads;    private Thread[] myThreads;    public void scan(int threadsNumber, T[] array, Operation<T> operation) {        initSendReceiveTable(threadsNumber);        initThreads(threadsNumber, array, operation);        startThreads(threadsNumber);    }    private void startThreads(int threadsNumber) {        for (int i = 0; i < threadsNumber; i++) {            myThreads[i].start();        }        for (Thread thread : myThreads) {            try {                thread.join();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void initThreads(int threadsNumber, T[] array, Operation<T> operation) {        int step = array.length / threadsNumber;        int min = 0;        int max = step - 1;        myThreads = new ParallelPrefixScanThread[threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            myThreads[i] = new ParallelPrefixScanThread<>(min, max, array, i, sendReceiveTable, threadsNumber, operation);            min += step;            max += step;            if (i == threadsNumber - 2) {                max = array.length - 1;            }        }    }    private void initSendReceiveTable(int threadsNumber) {        sendReceiveTable = new Cell[threadsNumber][threadsNumber];        for (int i = 0; i < threadsNumber; i++) {            for (int j = 0; j < threadsNumber; j++) {                sendReceiveTable[i][j] = new Cell<>();            }        }    }}