package com.company.threads;import com.company.auxiliaries.Cell;import com.company.auxiliaries.Result;import com.company.operations.Operation;public abstract class MyThread<T> extends Thread {    private int pid;    private int threadsNumber;    private int minIndex;    private int maxIndex;    private Cell<T>[][] sendReceiveTable;    protected T[] sharedGenericArray;  //<-----------------------------------------------was private!    private Operation<T> operation;    //private Result<T> result;    public Operation<T> getOperation() {        return operation;    }    @Override    public void run() {    }    public MyThread(int minIndex, int maxIndex, T[] sharedGenericArray, int pid, Cell<T>[][] sendReceiveTable,                    int threadsNumber, Operation<T> operation) {        super();        this.pid = pid;        this.sendReceiveTable = sendReceiveTable;        setIndexes(minIndex, maxIndex);        this.sharedGenericArray = sharedGenericArray;        this.threadsNumber = threadsNumber;        setOperation(operation);    }    /*    public MyThread(int minIndex, int maxIndex, T[] sharedGenericArray, int pid, Cell<T>[][] sendReceiveTable,                    int threadsNumber, Operation<T> operation, Result<T> result) {        this(minIndex, maxIndex,sharedGenericArray,pid,sendReceiveTable,threadsNumber,operation);        this.result = result;    }     */    protected int getMinIndex() {        return minIndex;    }    protected int getMaxIndex() {        return maxIndex;    }    protected int getPid() {        return pid;    }    protected int getThreadsNumber() {        return threadsNumber;    }    protected <U extends Operation<T>> void doParallelPrefixScan(U operation) {        //the value of neutral element is supplied by operation        T total = operation.getNeutralElement();        for (int i = minIndex; i <= maxIndex; i++) {            total = operation.apply(total, sharedGenericArray[i]);        }        int k;        for (k = 1; k < threadsNumber; k *= 2) {            if ((pid & k) == 0) {                sendReceiveTable[pid][pid + k].send(total);                break;            }            else {                total = operation.apply(total, sendReceiveTable[pid - k][pid].receive());            }        }        // perform distribute phase        if (pid == threadsNumber - 1) {            total = operation.getNeutralElement();        }        if (k >= threadsNumber) {            k /= 2;        }        while (k > 0) {            if((pid & k) == 0) {                sendReceiveTable[pid][pid + k].send(total);                total = sendReceiveTable[pid + k][pid].receive();            }            else {                T received = sendReceiveTable[pid - k][pid].receive();                sendReceiveTable[pid][pid - k].send(total);                total = operation.apply(total, received);            }            k /= 2;        }        // update array to have the prefix sums        for (int i = minIndex; i <= maxIndex; i++) {            total = operation.apply(total, sharedGenericArray[i]);            sharedGenericArray[i] = total;        }    }    protected <U extends Operation<T>> void doParallelScan(U operation, Result<T> result) {        T total = sharedGenericArray[minIndex];        for (int i = minIndex + 1; i <= maxIndex; i++) {            total = operation.apply(total, sharedGenericArray[i]);        }        for (int k = 1; k < threadsNumber; k *= 2) {            if ((pid & k) != 0) {                sendReceiveTable[pid][pid - k].send(total);                break;            }            else if (pid + k < threadsNumber) {                total = operation.apply(total, sendReceiveTable[pid + k][pid].receive());            }        }        if (pid == 0) { //поток с id == 0 ответственен за сохранение результата            result.setResult(total);        }    }    protected <U extends Operation<T>> void doParallelScanFromLeftToRight(U operation, Result<T> result) {        T total = sharedGenericArray[minIndex];        for (int i = minIndex + 1; i <= maxIndex; i++) {            total = operation.apply(total, sharedGenericArray[i]);        }        for (int k = 1; k < threadsNumber; k *= 2) {            if ((pid & k) == 0) {                sendReceiveTable[pid][pid + k].send(total);                break;            }            else {                total = operation.apply(sendReceiveTable[pid - k][pid].receive(), total);            }        }        if (pid == threadsNumber - 1) {            result.setResult(total);        }    }    private void setIndexes(int minIndex, int maxIndex) {        this.maxIndex = maxIndex;        this.minIndex = minIndex;    }    private void setOperation(Operation<T> operation) {        this.operation = operation;    }}